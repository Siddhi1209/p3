
// get_queue_buildup_siddhi.c
// Writes queue counts to $HOME/Siddhi/queue_buildup_<DQP>.out
// Also writes timestamp with microseconds to $HOME/Siddhi/t11 as HH:MM:SS.mmmuuu

#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>
#include <time.h>
#include <sys/time.h>

#define Q_OFFSET        500
#define NUM_REGIONS     128
#define NUM_SYSTEMS     10
#define NUM_APPS        10
#define NUM_QUEUES      250
#define MAX_QUEUE_KEY   (Q_OFFSET+NUM_REGIONS*NUM_SYSTEMS*NUM_APPS*NUM_QUEUES)

char *importantQueues[] =
{
    "CASQ","CIFQ","CTAQ","DEPQ","DP1Q","DP2Q","DP3Q","DP4Q","DP5Q",
    "DP6Q","DP7Q","DP8Q","DP9Q","GL1Q","EQ1Q","ELMQ","GENQ","LONQ",
    "OLRQ","ONLQ","PF1Q","PFMQ","RESPQ","SBRQ","SDVQ","SPYQ","VPIQ",
    "VV1Q","VV2Q","VV3Q","ARCQ","CC1Q","KCCQ","FA1Q","SFDQ","GLAQ",
    "CRCQ","BLTQ","BL1Q",NULL
};

// You would paste your full queueTable[] here from original program.

char **multiplexedQueues;
int msgCount, msgQId;
FILE *filePointer;
char fileNameBuf[512];

static void write_timestamp_full_to_t11(void) {
    struct timeval tv;
    struct tm tmval;
    char path[512], buf[64];
    FILE *fp;
    const char *home = getenv("HOME");
    if (!home) return;

    gettimeofday(&tv, NULL);
    localtime_r(&tv.tv_sec, &tmval);

    int ms = (int)(tv.tv_usec / 1000);
    int us = (int)(tv.tv_usec % 1000);

    snprintf(path, sizeof(path), "%s/Siddhi/t11", home);
    snprintf(buf, sizeof(buf), "%02d:%02d:%02d.%03d%03d\n",
             tmval.tm_hour, tmval.tm_min, tmval.tm_sec, ms, us);

    fp = fopen(path, "w");
    if (!fp) return;
    fputs(buf, fp);
    fclose(fp);
}

int getQueueIndex(char queueName[]){
    extern char *queueTable[];
    int idx;
    for (idx=0; queueTable[idx]!=NULL; idx++)
        if (!strcmp(queueName,queueTable[idx]))
            break;
    if (queueTable[idx]==NULL)
        return -1;
    else
        return idx;
}

int getDQPType(){
    char *dqpPtr = getenv("BANCS_DQPTYPE");
    return (int)dqpPtr[0];
}

int getFNSSysnum(){
    char *fnsSysnumPtr = getenv("FNS_SYSNUM");
    return (int)(fnsSysnumPtr[0]-'0');
}

int getApplNo(){
    char *applNumPtr = getenv("BANCS_HOSTNO");
    return (int)(applNumPtr[0]-'0');
}

int loadQueueDetails(int queueKey){
    struct msqid_ds msgQueueID_DS;
    msgQId=msgget(queueKey, 0);
    if (msgQId==-1)
        return -1;
    else{
        if(msgctl(msgQId, IPC_STAT, &msgQueueID_DS)==-1)
            return -2;
        else{
            msgCount=msgQueueID_DS.msg_qnum;
            return 0;
        }
    }
}

int main(int argc, char *argv[])
{
    int queueIdx, idx, idx1, flag, bancsDQPType, fnsSysnum, bancsHostno, queueKey, loadQueueRC;
    char DQPType;

    multiplexedQueues = argv;

    bancsDQPType = getDQPType();
    fnsSysnum    = getFNSSysnum();
    bancsHostno  = getApplNo();
    DQPType      = (char)bancsDQPType;

    const char *home = getenv("HOME");
    if(!home) {
        fprintf(stderr, "HOME not set\n");
        return -1;
    }

    snprintf(fileNameBuf, sizeof(fileNameBuf), "%s/Siddhi/queue_buildup_%c.out", home, DQPType);
    filePointer=fopen(fileNameBuf, "w+");
    if(filePointer==NULL){
        printf("\nError opening file: %s", fileNameBuf);
        exit(-1);
    }

    write_timestamp_full_to_t11();

    for (idx=0; importantQueues[idx]!=NULL; idx++){
        flag=0;
        queueIdx=getQueueIndex(importantQueues[idx]);

        if(queueIdx==-1){
            fprintf(filePointer, "%s NSQE\n", importantQueues[idx]);
        } else {
            queueKey = Q_OFFSET + queueIdx
                     + NUM_QUEUES * (bancsHostno + NUM_APPS * (fnsSysnum + NUM_SYSTEMS * bancsDQPType));
            loadQueueRC=loadQueueDetails(queueKey);
            if(loadQueueRC==-1){
                for (idx1=1; idx1 < argc; idx1++){
                    if(!strcmp(importantQueues[idx],multiplexedQueues[idx1])){
                        fprintf(filePointer, "%s B, NQKE\n",importantQueues[idx]);
                        flag=1;
                    }
                }
                if(flag==0){
                    fprintf(filePointer, "%s\tNQKE\n", importantQueues[idx]);
                }
            } else if(loadQueueRC==-2){
                fprintf(filePointer, "LDQE\n");
            } else {
                fprintf(filePointer, "%s\t%d\n", importantQueues[idx], msgCount);
            }
        }
    }

    fclose(filePointer);
    return 0;
}
