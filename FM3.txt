
// get_queue_buildup.c  (PRODUCTION VERSION)
// Writes queue counts to $HOME/queue_buildup_<DQP>.out
// Also writes timestamp with microseconds to $HOME/t11 as HH:MM:SS.mmmuuu

#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>
#include <time.h>
#include <sys/time.h>

#define Q_OFFSET        500
#define NUM_REGIONS     128
#define NUM_SYSTEMS     10
#define NUM_APPS        10
#define NUM_QUEUES      250
#define MAX_QUEUE_KEY   (Q_OFFSET+NUM_REGIONS*NUM_SYSTEMS*NUM_APPS*NUM_QUEUES)

/* ===== Full queueTable[] (from your original) ===== */
char *queueTable[] =
{
        "BANCSQ",
        "LINKINQ",
        "LINKOUTQ",
        "SYSSTARTQ",
        "DJ0000Q",
        "SY0020Q",
        "SY0040Q",
        "SY0050Q",
        "SY0070Q",
        "CDRUTHERQ",
        "CDRDELAYQ",
        "CDTRACERQ",
        "SCCQ",
        "SCCOPINQ",

        /* A Interface queues */
        "AT0000Q",
        "AT0100Q",
        "AT0110Q",
        "AT0200Q",
        "AT0300Q",
        "AT0210Q",
        /* START of IR R331 (Revert IR 18794) */
        "EI0000Q",
        "EI0060Q",
        /* END of IR R331 */

        /* Five EI0060Q s added for A Gateway IR 18794 */
        "ATINQ",
        "ATOUTQ",
        "ATRDELAYQ",
        "ATRUTHERQ",
        "ATTRACERQ",
        "ACSQ",
        "ACTLQ",
        "INPUTQ",
        "TRICKLEQ",
        "INTERAPQ",
        "OPQ",
        "CONSOLEQ",
        "SY0004Q",
        "DEPQ",
        "LONQ",
        "TXPQ",
        "CIFQ",
        "GENQ",
        "CASQ",
        "PFMQ",
        "VPIQ",
        "SDVQ",
        "VISQ",
        "WBSQ",
        "CTAQ",
        "SBRQ",
        "ELMQ",
        "LIMQ",
        "EXPQ",
        "FN1Q",
        "FXCQ",
        "TDRQ",
        "SECQ",
        "EPSQ",
        "SPYQ",
        "OLRQ",
        "ONLQ",
        "RESPQ",
        "SB0100Q",
        "DP1Q",
        "DP2Q",
        "DP3Q",
        "DP4Q",
        "DP5Q",
        "DP6Q",
        "DP7Q",
        "DP8Q",
        "DP9Q",
        "VV1Q",
        "VV2Q",
        "VV3Q",
        "ARCQ",
        "CC1Q",
        "KCCQ",
        "LN1Q",
        "PF1Q",
        "GL1Q",
        "EQ1Q",
        "FA1Q",
        "NW1Q",
        "NW2Q",
        "NW3Q",
        "SFDQ",
        "GLAQ",
        "CRCQ",
        "BLTQ",
        "BL1Q",
        "DEPOPINQ",
        "LONOPINQ",
        "CIFOPINQ",
        "GENOPINQ",
        "CASOPINQ",
        "PFMOPINQ",
        "VISOPINQ",
        "WBSOPINQ",
        "CTAOPINQ",
        "ELMOPINQ",
        "LIMOPINQ",
        "EXPOPINQ",
        "FN1OPINQ",
        "FXCOPINQ",
        "TDROPINQ",
        "SECOPINQ",
        "TERMINALQ",
        "SECMAINQ",
        "SY3000Q",
        "TXPOPINQ",
        "SWIFTINQ",
        "REPLAYQ",
        "REPLAY01Q",
        "REPLAY02Q",
        "REPLAY03Q",
        "TMMOPINQ",
        "TMMQ",
        "TBGOPINQ",
        "TBGQ",
        "PYNMAINQ",
        "SPYOPINQ",
        "PYIMAINQ",
        "PYMMAINQ",
        "PYOMAINQ",
        "PYLMAINQ",
        "GIRMAINQ",
        "OLROPINQ",

        /* Telepac queues */
        "TPAC1",
        "TPAC2",
        "TPAC3",
        "TPOST",
        "TPCQ",
        "TPCOPINQ",
        /* New Intersystem -interface to BOSS- Queue */
        "MHSQ",

        /* Unknown */
        "ARD0001",
        "AIO0001",
        "ARD0002",
        "AIO0002",
        "AJNL",
        "DBDUM",
        "DYMON",
        "ENQRY",
        "HWCRP",
        "KMNGR",
        "MAINT",
        "NAMES",
        "START",
        "SUPER",
        "TLLR1",
        "SPARE!!!!",
        "CHQMDQ",
        "JSMCONSQ",
        "JSMGENERQ",
        "JSMNEXTQ",
        "JSMSTARTQ",
        "CRDEV0005",
        "NDUMP",
        "DIBLD",
        "DIBRD0002",
        "RPORT",
        "DXLNK",
        "DXL25W001",
        "DXL25W002",
        "RTLNK",
        "RETRY",
        "TEST",
        "DXL25W003",
        "DXL25W004",
        "RTL25W001",
        "RTL25W002",
        "SWIFT2Q",
        "MSETT",
        NULL
};

/* ===== importantQueues[] (one per line) ===== */
char *importantQueues[] =
{
        "CASQ",
        "CIFQ",
        "CTAQ",
        "DEPQ",
        "DP1Q",
        "DP2Q",
        "DP3Q",
        "DP4Q",
        "DP5Q",
        "DP6Q",
        "DP7Q",
        "DP8Q",
        "DP9Q",
        "GL1Q",
        "EQ1Q",
        "ELMQ",
        "GENQ",
        "LONQ",
        "OLRQ",
        "ONLQ",
        "PF1Q",
        "PFMQ",
        "RESPQ",
        "SBRQ",
        "SDVQ",
        "SPYQ",
        "VPIQ",
        "VV1Q",
        "VV2Q",
        "VV3Q",
        "ARCQ",
        "CC1Q",
        "KCCQ",
        "FA1Q",
        "SFDQ",
        "GLAQ",
        "CRCQ",
        "BLTQ",
        "BL1Q",
        NULL
};

/* multiplexed queues (argv-driven) */
char **multiplexedQueues;

int msgCount, msgQId;
FILE *filePointer;
char  fileNameBuf[512];

/* write HH:MM:SS.mmmuuu to $HOME/t11 */
static void write_timestamp_full_to_t11(void) {
        struct timeval tv;
        struct tm tmval;
        char path[512], buf[64];
        FILE *fp;
        const char *home = getenv("HOME");
        if (!home) return;

        gettimeofday(&tv, NULL);
        localtime_r(&tv.tv_sec, &tmval);

        int ms = (int)(tv.tv_usec / 1000);
        int us = (int)(tv.tv_usec % 1000);

        snprintf(path, sizeof(path), "%s/t11", home);
        snprintf(buf, sizeof(buf), "%02d:%02d:%02d.%03d%03d\n",
                 tmval.tm_hour, tmval.tm_min, tmval.tm_sec, ms, us);

        fp = fopen(path, "w");
        if (!fp) return;
        fputs(buf, fp);
        fclose(fp);
}

int getMultQueIndex(char queueName[],int multQueCount){
        int idx;
        for(idx=1; idx < multQueCount; idx++)
                if(!strcmp(queueName,multiplexedQueues[idx]))
                        break;
        return (idx == multQueCount) ? 0 : 1;
}

int getQueueIndex(char queueName[]){
        int idx;
        for (idx=0; queueTable[idx]!=NULL; idx++)
                if (!strcmp(queueName,queueTable[idx]))
                        break;
        return (queueTable[idx]==NULL) ? -1 : idx;
}

int getDQPType(){
        char *dqpPtr=getenv("BANCS_DQPTYPE");
        return (int)dqpPtr[0];
}
int getFNSSysnum(){
        char *p=getenv("FNS_SYSNUM");
        return (int)(p[0]-'0');
}
int getApplNo(){
        char *p=getenv("BANCS_HOSTNO");
        return (int)(p[0]-'0');
}

int loadQueueDetails(int queueKey){
        struct msqid_ds ds;
        msgQId=msgget(queueKey, 0);
        if (msgQId==-1) return -1;
        if (msgctl(msgQId, IPC_STAT, &ds)==-1) return -2;
        msgCount=ds.msg_qnum;
        return 0;
}

int main(int argc, char *argv[])
{
        int queueIdx, idx, idx1, flag, bancsDQPType, fnsSysnum, bancsHostno, queueKey, rc;
        char DQPType;

        multiplexedQueues = argv;

        bancsDQPType=getDQPType();
        fnsSysnum=getFNSSysnum();
        bancsHostno=getApplNo();
        DQPType=(char)bancsDQPType;

        const char *home = getenv("HOME");
        if(!home) { fprintf(stderr,"HOME not set\n"); return -1; }

        /* PRODUCTION path: $HOME/queue_buildup_<DQP>.out */
        snprintf(fileNameBuf, sizeof(fileNameBuf), "%s/queue_buildup_%c.out", home, DQPType);

        filePointer=fopen(fileNameBuf, "w+");
        if(filePointer==NULL){ printf("\nError opening file: %s", fileNameBuf); exit(-1); }

        /* write HH:MM:SS.mmmuuu to $HOME/t11 */
        write_timestamp_full_to_t11();

        /* main loop: for each important queue */
        for (idx=0; importantQueues[idx]!=NULL; idx++){
                flag=0;
                queueIdx=getQueueIndex(importantQueues[idx]);

                if(queueIdx==-1){
                        fprintf(filePointer, "%s NSQE\n", importantQueues[idx]);
                        continue;
                }

                queueKey=Q_OFFSET+queueIdx+NUM_QUEUES*(bancsHostno+NUM_APPS*(fnsSysnum+NUM_SYSTEMS*bancsDQPType));
                rc=loadQueueDetails(queueKey);
                if(rc==-1){
                        for (idx1=1; idx1 < argc; idx1++){
                                if(!strcmp(importantQueues[idx], multiplexedQueues[idx1])){
                                        fprintf(filePointer, "%s B, NQKE\n", importantQueues[idx]);
                                        flag=1;
                                }
                        }
                        if(flag==0) fprintf(filePointer, "%s\tNQKE\n", importantQueues[idx]);
                } else if(rc==-2){
                        fprintf(filePointer, "LDQE\n");
                } else {
                        fprintf(filePointer, "%s\t%d\n", importantQueues[idx], msgCount);
                }

                /* multiplexed A / I / M */
                if(getMultQueIndex(importantQueues[idx], argc)){
                        queueKey = Q_OFFSET+queueIdx+510+NUM_QUEUES*(bancsHostno+NUM_APPS*(fnsSysnum+NUM_SYSTEMS*bancsDQPType));
                        rc=loadQueueDetails(queueKey);
                        if(rc==-1) fprintf(filePointer, "%s A, NQKE\n",importantQueues[idx]);
                        else if(rc==-2) fprintf(filePointer, "%s A, LDQE\n",importantQueues[idx]);
                        else fprintf(filePointer, "%s A, %d\n",importantQueues[idx], msgCount);

                        queueKey = Q_OFFSET+queueIdx+520+NUM_QUEUES*(bancsHostno+NUM_APPS*(fnsSysnum+NUM_SYSTEMS*bancsDQPType));
                        rc=loadQueueDetails(queueKey);
                        if(rc==-1) fprintf(filePointer, "%s I, NQKE\n",importantQueues[idx]);
                        else if(rc==-2) fprintf(filePointer, "%s I, LDQE\n",importantQueues[idx]);
                        else fprintf(filePointer, "%s I, %d\n", importantQueues[idx], msgCount);

                        queueKey = Q_OFFSET+queueIdx+530+NUM_QUEUES*(bancsHostno+NUM_APPS*(fnsSysnum+NUM_SYSTEMS*bancsDQPType));
                        rc=loadQueueDetails(queueKey);
                        if(rc==-1) fprintf(filePointer, "%s M, NQKE\n",importantQueues[idx]);
                        else if(rc==-2) fprintf(filePointer, "%s M, LDQE\n",importantQueues[idx]);
                        else fprintf(filePointer, "%s M, %d\n", importantQueues[idx], msgCount);
                }
        }

        fclose(filePointer);
        return 0;
}
